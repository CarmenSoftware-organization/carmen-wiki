---
title: วิธีการคำนวณต้นทุนสินค้าคงคลัง: FIFO เทียบกับ ต้นทุนถัวเฉลี่ย
description: เอกสารวิเคราะห์วิธีการคำนวณต้นทุนสินค้าคงคลัง FIFO และต้นทุนถัวเฉลี่ย สำหรับแพลตฟอร์ม Carmen Software
published: true
date: 2026-02-16T11:19:18.975Z
tags: inventory, costing, fifo, weighted-average, carmen-software
editor: markdown
dateCreated: 2026-02-16T11:19:18.975Z
---

# วิธีการคำนวณต้นทุนสินค้าคงคลัง: FIFO เทียบกับ ต้นทุนถัวเฉลี่ย

## 1. ภาพรวม

เอกสารนี้วิเคราะห์วิธีการคิดต้นทุนสินค้าคงคลัง 2 วิธีหลักสำหรับแพลตฟอร์มบริหารสินค้าคงคลัง:

- **FIFO (เข้าก่อน-ออกก่อน)**: สินค้าที่ซื้อเข้ามาก่อนจะถูกขาย/ใช้ก่อน
- **ต้นทุนถัวเฉลี่ย (Weighted Average)**: สินค้าทั้งหมดจะถูกตีมูลค่าด้วยต้นทุนถัวเฉลี่ยถ่วงน้ำหนัก

ทั้งสองวิธีใช้กำหนด **ต้นทุนสินค้าขาย (COGS)** และ **มูลค่าสินค้าคงเหลือปลายงวด** ซึ่งส่งผลโดยตรงต่อการรายงานทางการเงินและการตัดสินใจด้านการดำเนินงาน

---

## 2. FIFO (เข้าก่อน-ออกก่อน)

### 2.1 แนวคิด

FIFO ถือว่าสินค้าคงคลังที่เก่าที่สุดจะถูกใช้ก่อน แต่ละล็อตที่ซื้อเข้ามาจะคงต้นทุนเดิมไว้จนกว่าจะถูกใช้หมด

### 2.2 วิธีการทำงาน

```
ล็อตซื้อที่ 1: 100 หน่วย @ ฿10.00
ล็อตซื้อที่ 2:  50 หน่วย @ ฿12.00
ล็อตซื้อที่ 3:  80 หน่วย @ ฿11.50

เบิกออก 120 หน่วย:
  - 100 หน่วย จากล็อตที่ 1 @ ฿10.00 = ฿1,000.00
  -  20 หน่วย จากล็อตที่ 2 @ ฿12.00 = ฿  240.00
  - ต้นทุนสินค้าขายรวม = ฿1,240.00

สินค้าคงเหลือ:
  - 30 หน่วย จากล็อตที่ 2 @ ฿12.00 = ฿360.00
  - 80 หน่วย จากล็อตที่ 3 @ ฿11.50 = ฿920.00
  - รวม = ฿1,280.00 (110 หน่วย)
```

### 2.3 โมเดลข้อมูล

การเคลื่อนไหวสินค้าคงคลังแต่ละรายการต้องติดตามข้อมูล **ล็อต/แบตช์**:

```
inventory_lot (ล็อตสินค้าคงคลัง):
  - lot_id          (PK)
  - product_id      (FK)
  - warehouse_id    (FK)
  - purchase_date   (timestamp)       -- วันที่ซื้อ
  - quantity         (decimal)         -- จำนวนคงเหลือในล็อตนี้
  - unit_cost        (decimal)         -- ต้นทุนซื้อเดิม
  - created_at       (timestamp)

inventory_transaction (รายการเคลื่อนไหวสินค้า):
  - transaction_id   (PK)
  - product_id       (FK)
  - warehouse_id     (FK)
  - transaction_type (enum: IN, OUT, ADJUST)  -- รับเข้า, เบิกออก, ปรับปรุง
  - quantity          (decimal)
  - reference_doc     (varchar)        -- เลขที่ใบสั่งซื้อ, เลขที่ใบสั่งขาย ฯลฯ
  - created_at        (timestamp)

inventory_transaction_lot (รายการเคลื่อนไหวตามล็อต):
  - transaction_id   (FK)
  - lot_id           (FK)
  - quantity          (decimal)        -- จำนวนที่ใช้จากล็อตนี้
  - unit_cost         (decimal)        -- ต้นทุน ณ เวลาที่ใช้
```

### 2.4 อัลกอริทึม (การเบิกสินค้า)

```
function issueStock_FIFO(productId, warehouseId, requiredQty):
    lots = getLots(productId, warehouseId)
             .filter(qty > 0)
             .orderBy(purchase_date ASC)  // เก่าสุดก่อน

    totalCost = 0
    remaining = requiredQty

    for each lot in lots:
        if remaining <= 0:
            break

        consume = min(lot.quantity, remaining)
        totalCost += consume * lot.unit_cost
        lot.quantity -= consume
        remaining -= consume

        recordTransactionLot(lot.id, consume, lot.unit_cost)

    if remaining > 0:
        throw InsufficientStockError  // สินค้าไม่เพียงพอ

    return totalCost
```

### 2.5 ข้อดี

| ข้อดี | รายละเอียด |
|-------|-----------|
| ติดตามต้นทุนได้แม่นยำ | แต่ละหน่วยคงต้นทุนซื้อจริง |
| ตรงกับการไหลของสินค้าจริง | เหมาะอย่างยิ่งสำหรับสินค้าที่เน่าเสียได้ |
| ดีกว่าในช่วงราคาขาขึ้น | ต้นทุนสินค้าขายต่ำกว่า กำไรรายงานสูงกว่า มูลค่าสินค้าคงเหลือสูงกว่า |
| มีเส้นทางการตรวจสอบ | ตรวจสอบย้อนกลับไปถึงแหล่งซื้อได้ทั้งหมด |

### 2.6 ข้อเสีย

| ข้อเสีย | รายละเอียด |
|---------|-----------|
| ความซับซ้อนสูง | ต้องติดตามล็อตแต่ละล็อต |
| ใช้พื้นที่จัดเก็บมากกว่า | แต่ละล็อตต้องมีเรคคอร์ดของตัวเอง |
| การเบิกช้ากว่า | ต้องวนลูปผ่านล็อตตามลำดับ |
| การจัดการล็อตที่ใช้บางส่วน | ล็อตอาจถูกใช้บางส่วน เพิ่มความซับซ้อน |

---

## 3. ต้นทุนถัวเฉลี่ย (Weighted Average)

### 3.1 แนวคิด

ต้นทุนถัวเฉลี่ยจะรวมต้นทุนของสินค้าทั้งหมดที่มีอยู่เป็นค่าเฉลี่ยถ่วงน้ำหนักเดียว สินค้าทุกหน่วยในคลังมีต้นทุนเท่ากัน ณ เวลาใดเวลาหนึ่ง

### 3.2 วิธีการทำงาน

```
ยอดเปิด:        0 หน่วย @ ฿0.00    | ต้นทุนเฉลี่ย = ฿0.00

ซื้อครั้งที่ 1:  100 หน่วย @ ฿10.00
  รวม:          100 หน่วย, มูลค่า = ฿1,000.00
  ต้นทุนเฉลี่ย = ฿1,000.00 / 100 = ฿10.00

ซื้อครั้งที่ 2:   50 หน่วย @ ฿12.00
  รวม:          150 หน่วย, มูลค่า = ฿1,000.00 + ฿600.00 = ฿1,600.00
  ต้นทุนเฉลี่ย = ฿1,600.00 / 150 = ฿10.6667

เบิกออก 120 หน่วย:
  ต้นทุนสินค้าขาย = 120 * ฿10.6667 = ฿1,280.00

คงเหลือ:         30 หน่วย * ฿10.6667 = ฿320.00

ซื้อครั้งที่ 3:   80 หน่วย @ ฿11.50
  รวม:          110 หน่วย, มูลค่า = ฿320.00 + ฿920.00 = ฿1,240.00
  ต้นทุนเฉลี่ย = ฿1,240.00 / 110 = ฿11.2727
```

### 3.3 โมเดลข้อมูล

ไม่ต้องติดตามล็อต แต่ละคู่สินค้า-คลังสินค้าจะเก็บค่าเฉลี่ยที่คำนวณต่อเนื่อง:

```
inventory_balance (ยอดคงเหลือสินค้าคงคลัง):
  - product_id       (FK, composite PK)
  - warehouse_id     (FK, composite PK)
  - quantity          (decimal)         -- จำนวนคงเหลือปัจจุบัน
  - average_cost      (decimal)         -- ต้นทุนถัวเฉลี่ยถ่วงน้ำหนักปัจจุบัน
  - total_value       (decimal)         -- quantity * average_cost
  - updated_at        (timestamp)

inventory_transaction (รายการเคลื่อนไหวสินค้า):
  - transaction_id   (PK)
  - product_id       (FK)
  - warehouse_id     (FK)
  - transaction_type (enum: IN, OUT, ADJUST)  -- รับเข้า, เบิกออก, ปรับปรุง
  - quantity          (decimal)
  - unit_cost         (decimal)         -- ต้นทุนเฉลี่ย ณ เวลาที่ทำรายการ
  - total_cost        (decimal)
  - reference_doc     (varchar)
  - created_at        (timestamp)
```

### 3.4 อัลกอริทึม

```
function receiveStock_AVG(productId, warehouseId, receivedQty, purchaseCost):
    balance = getBalance(productId, warehouseId)

    newTotalValue = (balance.quantity * balance.average_cost)
                  + (receivedQty * purchaseCost)
    newTotalQty   = balance.quantity + receivedQty
    newAvgCost    = newTotalValue / newTotalQty

    balance.quantity     = newTotalQty
    balance.average_cost = newAvgCost
    balance.total_value  = newTotalValue

    recordTransaction(IN, receivedQty, purchaseCost)


function issueStock_AVG(productId, warehouseId, requiredQty):
    balance = getBalance(productId, warehouseId)

    if balance.quantity < requiredQty:
        throw InsufficientStockError  // สินค้าไม่เพียงพอ

    totalCost = requiredQty * balance.average_cost

    balance.quantity    -= requiredQty
    balance.total_value -= totalCost
    // ต้นทุนเฉลี่ยไม่เปลี่ยนแปลงเมื่อเบิกออก

    recordTransaction(OUT, requiredQty, balance.average_cost)

    return totalCost
```

### 3.5 ข้อดี

| ข้อดี | รายละเอียด |
|-------|-----------|
| โมเดลข้อมูลง่ายกว่า | ไม่ต้องติดตามล็อต |
| การดำเนินงานเร็วกว่า | O(1) สำหรับทั้งการรับเข้าและเบิกออก |
| ใช้พื้นที่จัดเก็บน้อยกว่า | เรคคอร์ดเดียวต่อคู่สินค้า-คลังสินค้า |
| ลดผลกระทบจากราคาผันผวน | ลดผลกระทบจากความผันผวนของราคา |

### 3.6 ข้อเสีย

| ข้อเสีย | รายละเอียด |
|---------|-----------|
| ไม่สามารถตรวจสอบย้อนกลับต้นทุนได้ | ไม่สามารถตรวจสอบต้นทุนย้อนกลับไปยังการซื้อเฉพาะได้ |
| ปัญหาการปัดเศษ | การคำนวณซ้ำอาจสะสมความคลาดเคลื่อนจากการปัดเศษ |
| ไม่เหมาะกับสินค้าเน่าเสีย | ไม่มีการติดตามแบตช์/วันหมดอายุในตัว |
| ความซับซ้อนในการคำนวณใหม่ | การแก้ไขข้อผิดพลาดในอดีตต้องคำนวณรายการที่ตามมาทั้งหมดใหม่ |

---

## 4. ตารางเปรียบเทียบ

| เกณฑ์ | FIFO | ต้นทุนถัวเฉลี่ย |
|-------|------|----------------|
| **ความซับซ้อน** | สูง (จัดการล็อต) | ต่ำ (เรคคอร์ดยอดคงเหลือเดียว) |
| **ประสิทธิภาพ** | O(n) ต่อการเบิก (n = จำนวนล็อต) | O(1) ต่อการเบิก |
| **พื้นที่จัดเก็บ** | มากกว่า (เรคคอร์ดล็อต) | น้อยกว่า (ยอดคงเหลือเดียว) |
| **ความถูกต้องของต้นทุน** | ต้นทุนต่อหน่วยที่แน่นอน | ค่าประมาณแบบถัวเฉลี่ย |
| **การตรวจสอบย้อนกลับ** | ครบถ้วน (ระดับล็อต) | ไม่มี (รวมกันแล้ว) |
| **ความผันผวนของราคา** | สะท้อนการเปลี่ยนแปลงต้นทุนจริง | ลดความผันผวน |
| **สินค้าเน่าเสีย** | เหมาะสมอย่างยิ่ง | ไม่เหมาะสม |
| **การแก้ไขข้อผิดพลาด** | ง่ายกว่า (ปรับล็อตเฉพาะ) | ยากกว่า (คำนวณใหม่ทั้งสาย) |
| **รายงาน** | วิเคราะห์ต้นทุนละเอียด | รายงานง่ายกว่า |
| **มาตรฐานบัญชี** | IFRS และ GAAP ยอมรับ | IFRS และ GAAP ยอมรับ |

---

## 5. ตัวอย่างเปรียบเทียบเชิงตัวเลข

จากรายการเดียวกัน เปรียบเทียบผลลัพธ์:

```
รายการ:
  1. รับเข้า 100 หน่วย @ ฿10.00
  2. รับเข้า  50 หน่วย @ ฿12.00
  3. เบิกออก 120 หน่วย
  4. รับเข้า  80 หน่วย @ ฿11.50

                            FIFO            ต้นทุนถัวเฉลี่ย
                            ----            ----------------
หลังรับเข้าครั้งที่ 1:
  คงเหลือ                   100             100
  มูลค่าสินค้าคงคลัง        ฿1,000.00       ฿1,000.00
  ต้นทุนต่อหน่วย            ฿10.00          ฿10.00

หลังรับเข้าครั้งที่ 2:
  คงเหลือ                   150             150
  มูลค่าสินค้าคงคลัง        ฿1,600.00       ฿1,600.00
  ต้นทุนต่อหน่วย            แตกต่างตามล็อต   ฿10.6667

หลังเบิกออก 120 หน่วย:
  ต้นทุนสินค้าขาย           ฿1,240.00       ฿1,280.00
  คงเหลือ                   30              30
  มูลค่าสินค้าคงคลัง        ฿360.00         ฿320.00

หลังรับเข้าครั้งที่ 3:
  คงเหลือ                   110             110
  มูลค่าสินค้าคงคลัง        ฿1,280.00       ฿1,240.00
```

**ข้อสังเกตสำคัญ**: ในสถานการณ์ที่ราคาขาขึ้น FIFO จะให้ต้นทุนสินค้าขายต่ำกว่าและมูลค่าสินค้าคงเหลือสูงกว่าเมื่อเทียบกับต้นทุนถัวเฉลี่ย

---

## 6. ข้อพิจารณาในการออกแบบแพลตฟอร์ม

### 6.1 การรองรับทั้งสองวิธี

แพลตฟอร์มควรอนุญาตให้ตั้งค่าได้ในระดับ **องค์กรหรือหมวดหมู่สินค้า**:

```
organization_settings (การตั้งค่าองค์กร):
  - org_id                (FK)
  - costing_method        (enum: FIFO, AVERAGE)   -- วิธีคิดต้นทุน
  - allow_negative_stock  (boolean, default: false) -- อนุญาตสต๊อกติดลบ
  - decimal_precision     (integer, default: 4)     -- ความละเอียดทศนิยม

-- หรือตั้งตามหมวดหมู่สินค้า:
product_category (หมวดหมู่สินค้า):
  - category_id           (PK)
  - costing_method        (enum: FIFO, AVERAGE)   -- วิธีคิดต้นทุน
```

### 6.2 รูปแบบสถาปัตยกรรม (Strategy Pattern)

```
interface InventoryCostingStrategy:
    receiveStock(productId, warehouseId, qty, cost)    // รับสินค้าเข้า
    issueStock(productId, warehouseId, qty) -> totalCost  // เบิกสินค้าออก
    getValuation(productId, warehouseId) -> value       // ดึงมูลค่าสินค้า
    recalculate(productId, warehouseId, fromDate)       // คำนวณใหม่

class FIFOStrategy implements InventoryCostingStrategy:
    // การประมวลผลแบบล็อต

class AverageCostStrategy implements InventoryCostingStrategy:
    // การประมวลผลแบบถัวเฉลี่ยถ่วงน้ำหนัก

class CostingService:
    getStrategy(productId) -> InventoryCostingStrategy:
        method = getConfiguredMethod(productId)
        if method == FIFO:
            return FIFOStrategy()
        else:
            return AverageCostStrategy()
```

### 6.3 ขั้นตอนการประมวลผลรายการ

```
การรับสินค้าเข้า:
  1. ตรวจสอบใบสั่งซื้อ / เอกสารรับสินค้า
  2. กำหนดวิธีคิดต้นทุนสำหรับสินค้า
  3. ดำเนินการรับเข้าผ่าน Strategy ที่เหมาะสม
  4. บันทึกรายการเคลื่อนไหวสินค้าพร้อมรายละเอียดต้นทุน
  5. ปรับปรุงบัญชีแยกประเภท (เดบิต: สินค้าคงคลัง, เครดิต: เจ้าหนี้/เงินสด)

การเบิกสินค้าออก:
  1. ตรวจสอบใบสั่งขาย / เอกสารเบิกสินค้า
  2. ตรวจสอบจำนวนสินค้าคงเหลือ
  3. กำหนดวิธีคิดต้นทุนสำหรับสินค้า
  4. ดำเนินการเบิกออกผ่าน Strategy ที่เหมาะสม -> ได้ต้นทุนสินค้าขาย
  5. บันทึกรายการเคลื่อนไหวสินค้าพร้อมรายละเอียดต้นทุน
  6. ปรับปรุงบัญชีแยกประเภท (เดบิต: ต้นทุนสินค้าขาย, เครดิต: สินค้าคงคลัง)
```

### 6.4 กรณีพิเศษที่ต้องจัดการ

| กรณีพิเศษ | การจัดการแบบ FIFO | การจัดการแบบต้นทุนถัวเฉลี่ย |
|-----------|-------------------|---------------------------|
| **สต๊อกเป็นศูนย์ + รับเข้า** | สร้างล็อตใหม่ | ตั้งต้นทุนเฉลี่ย = ต้นทุนซื้อ |
| **คืนสินค้าให้ผู้ขาย** | กลับรายการล็อตเฉพาะ | คำนวณค่าเฉลี่ยใหม่ |
| **ลูกค้าคืนสินค้า** | สร้างล็อตใหม่ด้วยต้นทุนเดิม | คำนวณค่าเฉลี่ยใหม่ด้วยต้นทุนสินค้าคืน |
| **ปรับปรุงสต๊อก (+)** | สร้างล็อตด้วยต้นทุนที่ระบุ | คำนวณค่าเฉลี่ยใหม่ |
| **ปรับปรุงสต๊อก (-)** | ใช้จากล็อตที่เก่าที่สุด | ลดจำนวน คงต้นทุนเฉลี่ยเดิม |
| **โอนย้ายระหว่างคลัง** | ย้ายเรคคอร์ดล็อต | เบิกออกด้วยต้นทุนเฉลี่ย รับเข้าด้วยต้นทุนเดียวกัน |
| **สต๊อกติดลบ (ถ้าอนุญาต)** | ติดตามล็อตติดลบ | อนุญาตจำนวนติดลบ คงต้นทุนเฉลี่ย |
| **การปัดเศษ** | ปัดเศษต่อล็อต | เสี่ยงสะสมคลาดเคลื่อน - ใช้ความละเอียดสูง |

### 6.5 การคำนวณใหม่และการแก้ไขข้อผิดพลาด

เมื่อมีการแก้ไขรายการในอดีต รายการที่ตามมาทั้งหมดต้องถูกคำนวณใหม่:

```
function recalculate(productId, warehouseId, fromDate):
    // รีเซ็ตยอดคงเหลือไปยังสถานะก่อน fromDate
    balance = getSnapshotBefore(fromDate)

    // เล่นรายการทั้งหมดซ้ำตามลำดับเวลา
    transactions = getTransactions(productId, warehouseId, fromDate)
                    .orderBy(created_at ASC)

    for each txn in transactions:
        if txn.type == IN:
            strategy.receiveStock(txn.qty, txn.cost)
        else if txn.type == OUT:
            txn.updated_cost = strategy.issueStock(txn.qty)
            // อัปเดตเรคคอร์ดรายการด้วยต้นทุนที่แก้ไขแล้ว

    // บันทึกยอดคงเหลือสุดท้าย
    saveBalance(balance)
```

---

## 7. ข้อกำหนดด้านรายงาน

### 7.1 รายงานหลัก

| รายงาน | คำอธิบาย | ข้อมูล FIFO | ข้อมูลต้นทุนถัวเฉลี่ย |
|--------|---------|------------|---------------------|
| **มูลค่าสินค้าคงคลัง** | มูลค่าปัจจุบันของสินค้าคงคลังทั้งหมด | ผลรวมมูลค่าทุกล็อต | จำนวน * ต้นทุนเฉลี่ย |
| **รายงานต้นทุนสินค้าขาย** | ต้นทุนสินค้าที่เบิกออกในงวด | ต้นทุนล็อตจริงที่ใช้ | ต้นทุนเฉลี่ย ณ เวลาที่เบิก |
| **รายงานการเคลื่อนไหวสินค้า** | รายการรับเข้า/เบิกออกทั้งหมดพร้อมต้นทุน | รายละเอียดต่อล็อต | ต้นทุนเฉลี่ยต่อรายการ |
| **รายงานอายุสินค้า** | อายุสินค้าตามล็อต | รองรับโดยตรง | ไม่สามารถใช้ได้ |
| **ผลต่างราคา** | การเปลี่ยนแปลงราคาซื้อ | เห็นได้ต่อล็อต | ถูกดูดซับเข้าค่าเฉลี่ย |

### 7.2 เส้นทางการตรวจสอบ (Audit Trail)

ทุกรายการต้องบันทึก:
- ใครเป็นผู้ดำเนินการ
- เกิดขึ้นเมื่อใด
- อะไรเปลี่ยนแปลง (ค่าก่อน/หลัง)
- ทำไม (เอกสารอ้างอิง, รหัสเหตุผล)
- วิธีการคำนวณที่ใช้และรายละเอียดการคำนวณต้นทุน

---

## 8. คำแนะนำ

| สถานการณ์ | วิธีที่แนะนำ |
|-----------|-------------|
| อาหารและเครื่องดื่ม / สินค้าเน่าเสีย | **FIFO** (จำเป็นต้องติดตามแบตช์/วันหมดอายุ) |
| เวชภัณฑ์ | **FIFO** (ข้อกำหนดทางกฎหมายสำหรับการติดตามล็อต) |
| สินค้าโภคภัณฑ์ / สินค้าจำนวนมาก | **ต้นทุนถัวเฉลี่ย** (ง่ายกว่า ราคาผันผวน) |
| ค้าปลีกปริมาณสูง | **ต้นทุนถัวเฉลี่ย** (ประสิทธิภาพ ความเรียบง่าย) |
| การผลิตด้วยวัตถุดิบ | **ต้นทุนถัวเฉลี่ย** (วัตถุดิบผสมรวมกัน) |
| อิเล็กทรอนิกส์ / สินค้าที่มีหมายเลขซีเรียล | **FIFO** (ต้องติดตามซีเรียล/แบตช์) |
| องค์กรที่ใช้หลายวิธี | **รองรับทั้งสองวิธี** ตั้งค่าตามหมวดหมู่ |

### คำแนะนำสุดท้ายสำหรับแพลตฟอร์ม

**รองรับทั้งสองวิธี** ด้วยแนวทาง Strategy Pattern ซึ่งให้ประโยชน์ดังนี้:

1. **ความยืดหยุ่น** - หมวดหมู่สินค้าต่างๆ สามารถใช้วิธีที่แตกต่างกันได้
2. **การปฏิบัติตามกฎระเบียบ** - ตอบโจทย์ข้อกำหนดในหลากหลายอุตสาหกรรมและมาตรฐานบัญชี
3. **เส้นทางการเปลี่ยนผ่าน** - องค์กรสามารถเปลี่ยนวิธีได้ ณ ขอบเขตของรอบบัญชี
4. **ความได้เปรียบทางการแข่งขัน** - ดึงดูดตลาดได้กว้างกว่าแพลตฟอร์มที่รองรับวิธีเดียว

เริ่มต้นด้วย **ต้นทุนถัวเฉลี่ย** เป็นค่าเริ่มต้น (ง่ายกว่าในการพัฒนาและทดสอบ) จากนั้นเพิ่มการรองรับ **FIFO** ทั้งสองวิธีใช้โครงสร้างตารางรายการเดียวกัน แตกต่างกันเพียงวิธีการคำนวณและจัดเก็บต้นทุน
